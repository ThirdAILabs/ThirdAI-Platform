name: Integration testing of given tarball

on:
  workflow_call:
    inputs:
      docker_image_branch_name:
        description: "Branch name of the docker images"
        required: true
        type: string
      docker_image_version:
        description: "version of the docker images (with prefix 'v')"
        required: true
        type: string
        default: latest
      tarball_filename:
        description: "Tarball file name in the S3 bucket"
        required: true
        type: string
      b64_encoded_docker_registry_password:
        description: "Docker registry password for the branch image encoded in base64"
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        description: "AWS access key id"
        required: true
      AWS_SECRET_ACCESS_KEY:
        description: "AWS secret access key"
        required: true
      HOST_MACHINE_PRIVATE_KEY:
        description: "server machine's private key hosted on AWS"
        required: true
      HOST_MACHINE_PUBLIC_KEY:
        description: "server machine's public key hosted on AWS"
        required: true
      EMAIL:
        description: "Global admin email ID"
        required: true
      PASSWORD:
        description: "Global admin password"
        required: true
      GENAI_KEY:
        description: "GenAI key"
        required: true
    outputs:
      test_exit_code:
        description: "Exit code of the test-run"
        value: ${{ jobs.test.outputs.exit_code }}

jobs:
  setup_the_ec2_instances:
    runs-on: ubuntu-latest-8-cores
    outputs:
      server_machine_public_ip: ${{ steps.host_machine.outputs.public_ip }}
      task_runner_token: ${{ steps.task_runner.outputs.token }}
    steps:
      - name: Decode docker registry password
        run: |
          echo "docker_registry_password=$(echo -n "${{ inputs.b64_encoded_docker_registry_password }}" | base64 --decode)" >> $GITHUB_ENV
      - name: Install AWS CLI
        run: |
          # sudo apt-get update
          # sudo apt-get install -y awscli

      - name: Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set region us-east-1      # ec2-instances are in this region

      - name: Verify AWS CLI Setup
        run: |
          aws --version
          aws sts get-caller-identity
      
      # These instances already have the aws configured to pull thirdai-packages from the s3 bucket
      - name: start the ec2-instance
        run: |
          aws ec2 start-instances --instance-ids i-0d7c02e319be52e71 i-066bb0f7bfb7ef7a3
      
      - name: Wait for EC2 to be running
        run: |
          echo "Waiting for EC2 instance to start..."
          sleep 30

      - name: Fetch the public ip of the server machine
        id: host_machine
        run: |
          PUBLIC_IP=$(aws ec2 describe-instances \
              --instance-ids i-0d7c02e319be52e71 \
              --query "Reservations[0].Instances[0].PublicIpAddress" \
              --output text)
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
      
      - name: Create an identity file for ssh-login
        run: |
          echo "${{ secrets.HOST_MACHINE_PRIVATE_KEY }}" > /tmp/id_rsa
          chmod 600 /tmp/id_rsa

      - name: Download the package and run driver.sh
        run: |
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=120 -o ServerAliveCountMax=25 -i /tmp/id_rsa ubuntu@${{ steps.host_machine.outputs.public_ip }} <<EOF        
            aws s3 cp s3://thirdai-corp-public/ThirdAI-Platform-latest-release/${{ inputs.tarball_filename }} /home/ubuntu/

            # unzip the package
            mkdir -p /home/ubuntu/package/verbose
            tar -xvf ${{ inputs.tarball_filename }} -C /home/ubuntu/package

            cd /home/ubuntu/package

            # Modify the config.yml
            yq -i '
                .license_path = "/home/ubuntu/ndb_enterprise_license.json" |
                .admin_mail = "${{ secrets.EMAIL }}" |
                .admin_username = "admin" |
                .admin_password = "${{ secrets.PASSWORD }}" |
                .genai_key = "${{ secrets.GENAI_KEY }}" |
                .thirdai_platform_version = "${{ inputs.docker_image_version }}" |
                .platform_image_branch = "${{ inputs.docker_image_branch_name }}" |
                .docker_registry_password = "${{ env.docker_registry_password }}" |
                .login_method = "postgres" |
                .cluster_endpoint = "${{ steps.host_machine.outputs.public_ip }}" |
                .nodes[0].private_ip = "172.31.46.139" |
                .nodes[0].ssh_username = "ubuntu" |
                .nodes[0].connection_type = "local" |
                .nodes[1].private_ip = "172.31.45.183" |
                .nodes[1].ssh_username = "ubuntu" |
                .nodes[1].connection_type = "ssh"
            '  /home/ubuntu/package/config.yml

            # verbose dir would contain the stdout and stderr of the run
            mkdir -p /home/ubuntu/verbose/cleanup1

            # Run the cleanup script
            ./driver.sh ./config.yml --cleanup 1> /home/ubuntu/verbose/cleanup1/cleanup.out 2> /home/ubuntu/verbose/cleanup1/cleanup.err

            mkdir -p /home/ubuntu/verbose/installation
            # Run the driver.sh script
            ./driver.sh ./config.yml -v 1> /home/ubuntu/verbose/installation/installation.out 2> /home/ubuntu/verbose/installation/installation.err
          EOF

      - name: Fetch the task runner token
        id: task_runner
        run: |
          task_runner_token=$(ssh -o StrictHostKeyChecking=no \
          -o ServerAliveInterval=120 \
          -o ServerAliveCountMax=25 \
          -i /tmp/id_rsa \
          ubuntu@${{ steps.host_machine.outputs.public_ip }} \
          "grep 'Secret ID' '/opt/thirdai_platform/nomad_data/task_runner_token.txt' | awk '{print \$NF}'")
          echo "token=$task_runner_token" >> $GITHUB_OUTPUT
  test:
    strategy:
      fail-fast: false
    runs-on: ubuntu-latest
    needs: [setup_the_ec2_instances]
    outputs:
        exit_code: ${{ steps.backend_test_status.outputs.exit_code }}
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v2
      
      - name: Set up Python 3.9
        uses: actions/setup-python@v2
        with:
          python-version: 3.9

      - name: Install AWS CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y awscli

      - name: Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set region us-east-2    # docker test data is stored in the s3 bucket of this region

      - name: Verify AWS CLI Setup
        run: |
          aws --version
          aws sts get-caller-identity

      - name: Install requirements
        run: |
          cd headless
          pip install -r requirements.txt

      - name: Env variables
        run: |
          echo "SHARE_DIR=$HOME/nfs/dir" >> $GITHUB_ENV
          echo "GENAI_KEY=${{ secrets.GENAI_KEY }}" >> $GITHUB_ENV
          echo "TASK_RUNNER_TOKEN=${{ needs.setup_the_ec2_instances.outputs.task_runner_token }}"
          mkdir -p ${{ env.SHARE_DIR }}

      - name: Generate random run name
        id: random-run-name
        run: |
          echo "random_run_name=test_$(python3 -c "import secrets; print(secrets.token_urlsafe(8))")" >> $GITHUB_ENV
      
      - name: Run tests
        id: backend_test_status
        run: |
          set -e
          commands=(
              python3 -m headless.run_locally --base-url "http://${{ needs.setup_the_ec2_instances.outputs.server_machine_public_ip }}/api/" --email ${{ secrets.EMAIL }} --password ${{ secrets.PASSWORD }} --run-name ${{ env.random_run_name }} --dag NDB --on-prem --generation
              python3 -m headless.run_locally --base-url "http://${{ needs.setup_the_ec2_instances.outputs.server_machine_public_ip }}/api/" --email ${{ secrets.EMAIL }} --password ${{ secrets.PASSWORD }} --run-name ${{ env.random_run_name }} --dag UDT
              python3 -m headless.run_locally --base-url "http://${{ needs.setup_the_ec2_instances.outputs.server_machine_public_ip }}/api/" --email ${{ secrets.EMAIL }} --password ${{ secrets.PASSWORD }} --run-name ${{ env.random_run_name }} --dag UDT_DATAGEN
              python3 -m headless.run_locally --base-url "http://${{ needs.setup_the_ec2_instances.outputs.server_machine_public_ip }}/api/" --email ${{ secrets.EMAIL }} --password ${{ secrets.PASSWORD }} --run-name ${{ env.random_run_name }} --dag Recovery_Backup
          )
          exit_code=0
          for cmd in "${commands[@]}"; do
              if ! eval "$cmd"; then
              exit_code=$?
              break
              fi
          done
          echo "exit_code=$exit_code" >> $GITHUB_OUTPUT

      - name: Test Next.js frontend
        if: always()
        id: frontend_test_status
        run: |
          BASE_URL_WITHOUT_API=$(echo "http://${{ needs.setup_the_ec2_instances.outputs.server_machine_public_ip }}")
          echo "Testing frontend at $BASE_URL_WITHOUT_API"
          curl -f "$BASE_URL_WITHOUT_API" || exit 1
  
  clean_ec2_instances:
      runs-on: ubuntu-latest-8-cores
      needs: [setup_the_ec2_instances, test]
      # if: always()
      steps:
        - name: Install AWS CLI
          run: |
            sudo apt-get update
            sudo apt-get install -y awscli

        - name: Configure AWS credentials
          run: |
            aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws configure set region us-east-1

        - name: Verify AWS CLI Setup
          run: |
            aws --version
            aws sts get-caller-identity
        
        - name: Run cleanup script
          run: |
            ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=120 -o ServerAliveCountMax=25 -i /tmp/id_rsa ubuntu@${{ steps.host_machine.outputs.public_ip }} <<EOF
              cd /home/ubuntu/package

              mkdir -p /home/ubuntu/verbose/cleanup2
              ./driver.sh /home/ubuntu/package/config.yml --cleanup -v 1> /home/ubuntu/verbose/cleanup2/cleanup.out 2> /home/ubuntu/verbose/cleanup2/cleanup.err

              rm -rf /home/ubuntu/package "/home/ubuntu/${{ inputs.tarball_filename }}"
            EOF
        
        - name: Stop the ec2-machine
          run: |
            aws ec2 stop-instances --instance-ids i-0d7c02e319be52e71 i-066bb0f7bfb7ef7a3
      